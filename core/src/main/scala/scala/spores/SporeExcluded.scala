package scala.spores

import scala.language.implicitConversions
import scala.reflect.macros.whitebox.Context
import scala.language.experimental.macros

/**
  * Implicit conversion between spores and spores with excluded types.
  */
object SporeConv{
  implicit def sporeConv[T, R, A] (s: Spore[T, R]) : Spore[T, R] {type Excluded = A} = macro SporeConvImpl.convImplSpore[T, R, A]
  implicit def sporeConv[R, A] (s: NullarySpore[R]) : NullarySpore[ R] {type Excluded = A} = macro SporeConvImpl.convImplNullary[R, A]
  implicit def sporeConv[T1, T2, R, A] (s: Spore2[T1, T2, R]) : Spore2[T1, T2, R] {type Excluded = A} = macro SporeConvImpl.convImplSpore2[T1, T2, R, A]
  implicit def sporeConv[T1, T2, T3, R, A] (s: Spore3[T1, T2, T3, R]) : Spore3[T1, T2, T3, R] {type Excluded = A} = macro SporeConvImpl.convImplSpore3[T1, T2, T3, R, A]

}

object SporeConvImpl {

  /**
    * Creates a compile error "Expression has type '...', but type '...' is Excluded"
    * if a type mentioned in 's' is a subtype of a type in 'A'.
    * @tparam A
    *           A single type or a tuple. constructTree checks if types in the tuple appear in 's'.
    * @param s
    *        a Block expression generated by check, check2, checkNullary in MacroImpl.
    *        The block has the form
    *        { class anonclass extends Spore...[...] {...}
    *        new anonclass(...)
    *        }
    * @return  a modified expression of the form
    *          { class anonclass extends Spore...[...] {...}
    *            new anonclass(...) { type Excluded = (...) }
    *          }
    */
  def constructTree[A: c.WeakTypeTag] (c: Context) (s: c.Tree) : c.universe.Tree = {
    import c.universe._
    val atpe = weakTypeOf[A]

    // creates a list of types that appear in A (currently only up to 6 excluded types)
    val avoidedList : List[c.universe.Type] = {
      if (atpe <:< weakTypeOf[(Any, Any)] ||
        atpe <:< weakTypeOf[(Any, Any, Any)] ||
        atpe <:< weakTypeOf[(Any, Any, Any, Any)] ||
        atpe <:< weakTypeOf[(Any, Any, Any, Any, Any)] ||
        atpe <:< weakTypeOf[(Any, Any, Any, Any, Any, Any)])
        atpe.typeArgs
      else List[c.universe.Type](atpe)
    }

    // goes through a tree and produces a list of TypeTree:s that appear in the tree
    object traverser extends Traverser {
      var mentionedTypes = List[TypeTree]()
      override def traverse(tree: Tree) : Unit = tree match {
        case tt @ TypeTree() => mentionedTypes = tt :: mentionedTypes
        case _ => super.traverse(tree)
      }
    }
    traverser.traverse(s)

    val NothingType = typeOf[Nothing]
    /* Check that btm is indeed the
       bottom type and that tpe is not */
    def isBottomType(btm: Type, tpe: Type) =
      btm =:= NothingType && !(tpe =:= btm)

    /* This is the check: compiler error if some TypeTree
       in 's' has a type that is <:< of something in A */
    traverser.mentionedTypes.foreach(t =>
      avoidedList.foreach(at =>
        if (t.tpe <:< at && !isBottomType(t.tpe, at))
          c.error(t.pos, s"Expression has type '${t.tpe}', but type '$at' is Excluded")
    ))

    /* divides 's' into pieces that are put together
       to create a Spore[...] {type Excluded = ...} */
    val Block(l, new_instance) = s
    var class_def : Tree = null

    l.foreach((t: Tree) => t match {
      case ClassDef(_, _, _, _) =>
        class_def = t
      case _ =>
    })

    require(class_def != null)

    val q"new $_(...$class_constructor_args)" = new_instance
    val class_def_sym = class_def.symbol
    val new_tree =q"""
      $class_def
      new $class_def_sym(...$class_constructor_args) {type Excluded = $atpe}
      """

    debug(s"[Excluded] new_tree:\n $new_tree")
    //debug(s"[Excluded] showRaw(new_tree) =\n${showRaw(new_tree)}")
    new_tree
  }

  def convImplNullary[R: c.WeakTypeTag, A: c.WeakTypeTag] (c : Context) (s: c.Expr[NullarySpore[R]]) :
  c.Expr[NullarySpore[R] {type Excluded = A}] = {
    c.Expr[NullarySpore[R] {type Excluded = A}] (constructTree[A](c)(s.tree))
  }

  def convImplSpore[T: c.WeakTypeTag, R: c.WeakTypeTag, A: c.WeakTypeTag] (c : Context) (s: c.Expr[Spore[T, R]]) :
      c.Expr[Spore[T, R] {type Excluded = A}] = {
    c.Expr[Spore[T, R] {type Excluded = A}](constructTree[A](c)(s.tree))
  }

  def convImplSpore2[T1: c.WeakTypeTag, T2: c.WeakTypeTag, R: c.WeakTypeTag, A: c.WeakTypeTag] (c : Context) (s: c.Expr[Spore2[T1, T2, R]]) :
  c.Expr[Spore2[T1, T2, R] {type Excluded = A}] = {
    c.Expr[Spore2[T1, T2, R] {type Excluded = A}](constructTree[A](c)(s.tree))
  }

  def convImplSpore3[T1: c.WeakTypeTag, T2: c.WeakTypeTag, T3: c.WeakTypeTag, R: c.WeakTypeTag, A: c.WeakTypeTag] (c : Context) (s: c.Expr[Spore3[T1, T2, T3, R]]) :
  c.Expr[Spore3[T1, T2, T3, R] {type Excluded = A}] = {
    c.Expr[Spore3[T1, T2, T3, R] {type Excluded = A}](constructTree[A](c)(s.tree))
  }
}
