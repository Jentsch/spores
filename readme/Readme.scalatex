@import Main._
@import scala.spores._
@import scala.spores.readme.Readme._
@sect("Spores", scala.spores.version)

    @div
      @p
        @raw
          <a href="https://travis-ci.org/jvican/spores-spark"><img src="https://camo.githubusercontent.com/6b6e23e24c648ccd29152db1fbee32bf88eccb46/68747470733a2f2f7472617669732d63692e6f72672f6f6c6166757270672f7363616c61666d742e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/olafurpg/scalafmt.svg?branch=master" style="max-width:100%;"></a>
          <a href="https://gitter.im/heathermiller/spores?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://camo.githubusercontent.com/382ebf95f5b4df9275ac203229928db8c8fd5c50/68747470733a2f2f6261646765732e6769747465722e696d2f6f6c6166757270672f7363616c61666d742e737667" alt="Join the chat at https://gitter.im/olafurpg/scalafmt" data-canonical-src="https://badges.gitter.im/olafurpg/scalafmt.svg" style="max-width:100%;"></a>

      @p
        @lnk("Spores", repo) enable a safer use of closures in concurrent and distributed
        environments. They provide users fine-grained control over a function's
        environment, from constraining captured variables to excluding the use of certain
        types within a closure at compile-time. This turns to be useful when library authors
        want to guarantee properties of a function, e.g. serializable closures.
        For a full motivation, check
        @a(href := "http://docs.scala-lang.org/sips/pending/spores.html")("SIP-21").

    @sect("How to use")
      @p
        There is no production-ready version of spores.
        If you want to try the experimental version out, add it to your sbt dependencies with:
        @hl.scala
            libraryDependencies += "org.scala-lang.modules" %% "spores-core" % "0.3.0"

    @sect("Getting started")
      @p
        A spore has the following structure:

      @statement
        spore {
           val insider = 3.1415926535897932384626
           val outsider = foo // defined outside the scope
           () => println(s"I captured $insider and $outsider")
        }

      @p
        In short, a spore consists of two parts:
        @ul
            @li("A declaration of local variables that capture the environment of a lambda.")
            @li("An anonymous function that uses those variables plus those that are global accessible.")

      @p
        However, the above example may be overkill in certain cases. If you prefer not to write
        the spore header, you can try the alternative simpler syntax:

      @statement
        spore {
           () => println(s"I captured ${capture(insider)} and ${capture(outsider)}")
        }

       @note The insider variable is now defined in the enclosing scope.

@raw
    <a href="https://github.com/jvican/spores"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a>

    <script>
        // NOTE: Disables the sidebar because we don't really have anything to show there yet.
        // Gonna re-enable it back by deleting this <script/> block once we have something interesting.
        (function() {
          controller = scalatex.scrollspy.Controller();
          controller.main = function(config) {}
        })()
    </script>
